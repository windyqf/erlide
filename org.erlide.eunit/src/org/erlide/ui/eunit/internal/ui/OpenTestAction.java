/*******************************************************************************
 * Copyright (c) 2000, 2009 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
package org.erlide.ui.eunit.internal.ui;

import java.text.MessageFormat;

import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.text.BadLocationException;
import org.eclipse.jface.text.IDocument;
import org.eclipse.ui.texteditor.ITextEditor;
import org.erlide.core.erlang.ErlModelException;
import org.erlide.core.erlang.IErlElement;
import org.erlide.core.erlang.IErlFunction;
import org.erlide.core.erlang.IErlModule;
import org.erlide.core.erlang.IErlProject;
import org.erlide.core.erlang.ISourceRange;
import org.erlide.core.erlang.util.ErlangFunction;
import org.erlide.ui.eunit.internal.model.TestCaseElement;

/**
 * Open a class on a Test method.
 */
public class OpenTestAction extends OpenEditorAction {

	private final String fFunctionName;
	private IErlFunction fFunction = null;
	private final int fLineNumber;

	public OpenTestAction(final TestRunnerViewPart testRunnerPart,
			final TestCaseElement testCase) {
		this(testRunnerPart, testCase.getModuleName(), testCase
				.getTestFunctionName(), testCase.getLineNumber(), true);
		// XXX final String trace = testCase.getTrace();
		// if (trace != null) {
		// String rawClassName = TestElement.extractRawClassName(testCase
		// .getTestName());
		//			rawClassName = rawClassName.replaceAll("\\.", "\\\\."); //$NON-NLS-1$//$NON-NLS-2$
		//			rawClassName = rawClassName.replaceAll("\\$", "\\\\\\$"); //$NON-NLS-1$//$NON-NLS-2$
		// final Pattern pattern = Pattern.compile(FailureTrace.FRAME_PREFIX
		//					+ rawClassName + '.' + fMethodName + "\\(.*:(\\d+)\\)" //$NON-NLS-1$
		// );
		// final Matcher matcher = pattern.matcher(trace);
		// if (matcher.find()) {
		// try {
		// fLineNumber = Integer.parseInt(matcher.group(1));
		// } catch (final NumberFormatException e) {
		// // continue
		// }
		// }
		// }
	}

	public OpenTestAction(final TestRunnerViewPart testRunner,
			final String className) {
		this(testRunner, className, null, -1, true);
	}

	private OpenTestAction(final TestRunnerViewPart testRunner,
			final String className, final String functionName,
			final int lineNumber, final boolean activate) {
		super(testRunner, className, activate);
		// TODO PlatformUI.getWorkbench().getHelpSystem().setHelp(this,
		// IJUnitHelpContextIds.OPENTEST_ACTION);
		fFunctionName = functionName;
		fLineNumber = lineNumber;
	}

	protected IErlElement findElement(final IErlProject project,
			final String moduleName) throws ErlModelException {
		final IErlModule module = findModule(project, moduleName);
		if (module == null) {
			return null;
		}
		if (fFunctionName == null) {
			return module;
		}
		final IErlFunction function = findFunction(module);
		if (function == null) {
			final String title = "Go To Test";
			final String message = MessageFormat.format(
					"Function ''{0}'' not found. Opening the test module.",
					fFunctionName);
			MessageDialog.openInformation(getShell(), title, message);
			return module;
		}

		fFunction = function;
		return function;
	}

	private IErlFunction findFunction(final IErlModule module) {
		// XXX final IStatus status = JavaConventionsUtil.validateMethodName(
		// fFunctionName, module);
		// if (!status.isOK()) {
		// return null;
		// }
		final IErlFunction function = module.findFunction(new ErlangFunction(
				fFunctionName, 0));
		if (function != null && function.exists()) {
			return function;
		}
		return null;
	}

	@Override
	protected void reveal(final ITextEditor textEditor) {
		if (fLineNumber >= 0) {
			try {
				final IDocument document = textEditor.getDocumentProvider()
						.getDocument(textEditor.getEditorInput());
				final int lineOffset = document.getLineOffset(fLineNumber - 1);
				final int lineLength = document.getLineLength(fLineNumber - 1);
				if (fFunction != null) {
					ISourceRange sr = null;
					try {
						sr = fFunction.getSourceRange();
					} catch (final ErlModelException e) {
					}
					if (sr == null
							|| sr.getOffset() == -1
							|| lineOffset < sr.getOffset()
							|| sr.getOffset() + sr.getLength() < lineOffset
									+ lineLength) {
						throw new BadLocationException();
					}
				}
				textEditor.selectAndReveal(lineOffset, lineLength);
				return;
			} catch (final BadLocationException x) {
				// marker refers to invalid text position -> do nothing
			}
		}
		if (fFunction != null) {
			final ISourceRange range = fFunction.getNameRange();
			if (range != null && range.getOffset() >= 0) {
				textEditor
						.selectAndReveal(range.getOffset(), range.getLength());
			}
		}
	}

}
